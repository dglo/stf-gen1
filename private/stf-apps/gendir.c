/* gendir.c, generate the stfDirectory file automatically
 * from a list of xml files...
 */
#include <stdio.h>
#include <stdlib.h>

#include <libxml/xmlmemory.h>
#include <libxml/parser.h>

#include "stf.h"

struct ParamNodeStruct;
typedef struct ParamNodeStruct ParamNode;

struct ParamNodeStruct {
   STF_PARAM parm;
   ParamNode *next;
};

struct DescNodeStruct;
typedef struct DescNodeStruct DescNode;

struct DescNodeStruct {
   STF_DESCRIPTOR desc;
   ParamNode *parms;
   DescNode *next;
};

static void usage(void) {
   fprintf(stderr, "usage: gendir xmlfiles...\n");
}

static DescNode *parseFile(const char *fn, DescNode *next) {
   xmlDocPtr doc;
   xmlNodePtr cur;
   DescNode *dn = (DescNode *) malloc(sizeof(DescNode));

   if (dn==NULL) {
      fprintf(stderr, "gendir: unable to allocate memory\n");
      return NULL;
   }
   dn->parms = NULL;
   dn->next = NULL;

   if ((doc = xmlParseFile(fn))==NULL) {
      fprintf(stderr, "gendir: can't parse file!\n");
      return NULL;
   }

   if ((cur = xmlDocGetRootElement(doc))==NULL) {
      fprintf(stderr, "gendir: empty document\n");
      xmlFreeDoc(doc);
      return NULL;
   }

   if (xmlStrcmp(cur->name, (const xmlChar *) "test")) {
      fprintf(stderr, "gendir: not a stf test document\n");
      xmlFreeDoc(doc);
      return NULL;
   }
   
   for (cur=cur->xmlChildrenNode; cur!=NULL; cur=cur->next) {
      if (xmlStrcmp(cur->name, (const xmlChar *) "name")==0) {
	 dn->desc.name = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);
      }
      else if (xmlStrcmp(cur->name, (const xmlChar *) "desc")==0) {
	 dn->desc.desc = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);
      }
      else if (xmlStrcmp(cur->name, (const xmlChar *) "majorVersion")==0) {
	 dn->desc.majorVersion = 
	    atoi(xmlNodeListGetString(doc, cur->xmlChildrenNode, 1));
      }
      else if (xmlStrcmp(cur->name, (const xmlChar *) "minorVersion")==0) {
	 dn->desc.minorVersion = 
	    atoi(xmlNodeListGetString(doc, cur->xmlChildrenNode, 1));
      }
      else if (xmlStrcmp(cur->name, (const xmlChar *) "testRunnable")==0) {
	 dn->desc.testRunnable = 
	    xmlStrcmp(xmlNodeListGetString(doc, cur->xmlChildrenNode, 1),
		      (const xmlChar *) "TRUE")==0;
      }
      else if (xmlStrcmp(cur->name, (const xmlChar *) "param")==0) {
	 ParamNode *pn = (ParamNode *) malloc(sizeof(ParamNode));
	 xmlNodePtr pxn = cur->xmlChildrenNode;
	 
	 if (pn==NULL) {
	    fprintf(stderr, "gendir: unable to allocate memory\n");
	    xmlFreeDoc(doc);
	    return NULL;
	 }

	 for (pxn = cur->xmlChildrenNode; pxn!=NULL; pxn=pxn->next) {
	    if (xmlStrcmp(pxn->name, (const xmlChar *) "name")==0) {
	       pn->parm.name = 
		  xmlNodeListGetString(doc, pxn->xmlChildrenNode, 1);
	    }
	    else if (xmlStrcmp(pxn->name, (const xmlChar *) "class")==0) {
	       pn->parm.class = 
		  xmlNodeListGetString(doc, pxn->xmlChildrenNode, 1);
	    }
	    else if (xmlStrcmp(pxn->name, (const xmlChar *) "type")==0) {
	       pn->parm.type = 
		  xmlNodeListGetString(doc, pxn->xmlChildrenNode, 1);
	    }
	    else if (xmlStrcmp(pxn->name, (const xmlChar *) "maxValue")==0) {
	       pn->parm.maxValue = 
		  xmlNodeListGetString(doc, pxn->xmlChildrenNode, 1);
	    }
	    else if (xmlStrcmp(pxn->name, (const xmlChar *) "minValue")==0) {
	       pn->parm.minValue = 
		  xmlNodeListGetString(doc, pxn->xmlChildrenNode, 1);
	    }
	    else if (xmlStrcmp(pxn->name, (const xmlChar *) "defValue")==0) {
	       pn->parm.defValue = 
		  xmlNodeListGetString(doc, pxn->xmlChildrenNode, 1);
	    }
	    else if (xmlStrcmp(pxn->name, (const xmlChar *) "arraySize")==0) {
	       pn->parm.arraySize = 
		  xmlNodeListGetString(doc, pxn->xmlChildrenNode, 1);
	       pn->parm.arrayLength = atoi(pn->parm.arraySize); 
	    }
	 }

	 /* link this param...
	  */
	 pn->next = dn->parms;
	 dn->parms = pn;
      }
   }
   
   return dn;
}

static int nparams(const DescNode *node) {
   ParamNode *p;
   int np = 0;
   for (p=node->parms; p!=NULL; p=p->next) np++;
   return np;
}


int main(int argc, char *argv[]) {
   int ai;
   DescNode *dn = NULL, *tdn;
   FILE *fptr;
   
   for (ai=1; ai<argc; ai++) {
      if (argv[ai][0]!='-') break;
   }

   if (ai>=argc) { 
      usage();
      return 1;
   }

   LIBXML_TEST_VERSION
   xmlKeepBlanksDefault(0);
   
   while (ai<argc) {
      if ((dn = parseFile(argv[ai], dn))==NULL) {
	 fprintf(stderr, "gendir: can't parse file: '%s'\n", argv[ai]);
	 return 1;
      }
      
      ai++;
   }

   xmlCleanupParser();

   /* now generate directory file -- and header...
    */
   if ((fptr=fopen("stfDirectory.c", "w"))==NULL) {
      fprintf(stderr, "gendir: can't open stfDirectory.c!\n");
      return 1;
   }
   
   fprintf(fptr, 
	   "/* stdDirectory.c, automatically generated by gendir\n */\n");
   fprintf(fptr, "#include \"stf.h\"\n\n");
   
   for (tdn = dn; tdn!=NULL; tdn = tdn->next) {
      int i;
      const int np = nparams(tdn);
      ParamNode *tp = NULL;

      fprintf(fptr, "static STF_PARAM %s_params[%d] = {\n", 
	      tdn->desc.name, np);
      for (i=0, tp=tdn->parms; i<np; i++, tp=tp->next) {
	 fprintf(fptr, "   {\n");
	 fprintf(fptr, "     .name = \"%s\",\n", tp->parm.name);
	 fprintf(fptr, "     .class = \"%s\",\n", tp->parm.class);
	 fprintf(fptr, "     .type = \"%s\",\n", tp->parm.type);
	 fprintf(fptr, "     .maxValue = \"%s\",\n", tp->parm.maxValue);
	 fprintf(fptr, "     .minValue = \"%s\",\n", tp->parm.minValue);
	 fprintf(fptr, "     .defValue = \"%s\",\n", tp->parm.defValue);
	 fprintf(fptr, "     .arraySize = \"%s\",\n", tp->parm.arraySize);
	 fprintf(fptr, "     .value = {\n");
	 if (strcmp(tp->parm.type, CHAR_TYPE)==0) {
	    fprintf(fptr, 
		    "       .charValue = "
		    "\"%s\",\n", tp->parm.value.charValue);
	 }
	 else if (strcmp(tp->parm.type, UINT_TYPE)==0) {
	    fprintf(fptr, "       .intValue = %d,\n",
		    tp->parm.value.intValue);
	 }
	 else if (strcmp(tp->parm.type, ULONG_TYPE)==0) {
	    fprintf(fptr, 
		    "       .longValue = %ld",
		    tp->parm.value.longValue);
	 }
	 else if (strcmp(tp->parm.type, BOOLEAN_TYPE)==0) {
	    fprintf(fptr, 
		    "       .boolValue = %d,\n",
		    tp->parm.value.boolValue);
	 }
	 else if (strcmp(tp->parm.type, UINT_ARRAY_TYPE)==0) {
	    fprintf(fptr, "     .intArrayValue = &%s_%s_array,\n",
		    tdn->desc.name, tp->parm.name);
	 }
	 else if (strcmp(tp->parm.type, ULONG_ARRAY_TYPE)==0) {
	    fprintf(fptr, "     .longArrayValue = &%s_%s_array,\n",
		    tdn->desc.name, tp->parm.name);
	 }
	 else {
	    fprintf(stderr, "invalid type '%s'\n", tp->parm.type);
	    return 1;
	 }
	 fprintf(fptr, "     },\n");
	 fprintf(fptr, "     .arrayLength = %d\n", tp->parm.arrayLength);
	 fprintf(fptr, "   },\n");
      }
      fprintf(fptr, "   { .name = \"\" }\n");
      fprintf(fptr, "};\n");

      fprintf(fptr, "\n");
      fprintf(fptr, "extern void %sInit(STF_DESCRIPTOR *);\n", tdn->desc.name);
      fprintf(fptr, "extern void %sEntry(STF_DESCRIPTOR *);\n",
	      tdn->desc.name);
      
      fprintf(fptr, "\n");
      fprintf(fptr, "static STF_DESCRIPTOR %s_descriptor = {\n", 
	      tdn->desc.name);
      fprintf(fptr, "  .name = \"%s\",\n", tdn->desc.name);
      fprintf(fptr, "  .desc = \"%s\",\n", tdn->desc.desc);
      fprintf(fptr, "  .majorVersion = %d,\n", tdn->desc.majorVersion);
      fprintf(fptr, "  .minorVersion = %d,\n", tdn->desc.minorVersion);
      fprintf(fptr, "  .testRunnable = %d,\n", tdn->desc.testRunnable);
      fprintf(fptr, "  .nParams = %d,\n", np);
      fprintf(fptr, "  .params = %s_params,\n", tdn->desc.name);
      fprintf(fptr, "  .initPt = %sInit,\n", tdn->desc.name);
      fprintf(fptr, "  .entryPt = %sEntry,\n", tdn->desc.name);
      fprintf(fptr, "  .isInit = 0\n");
      fprintf(fptr, "};\n");
   }

   /* write the actual directory...
    */
   fprintf(fptr, "\nSTF_DESCRIPTOR *stfDirectory[]={\n");
   for (tdn = dn; tdn!=NULL; tdn = tdn->next) {
      fprintf(fptr, "   &%s_descriptor,\n", tdn->desc.name);
   }
   fprintf(fptr, "   NULL\n};\n");
   fclose(fptr);
   
   return 0;
}


